require File.dirname(__FILE__) + '/load.rb'

TypeNames = [8, 16, 32, 64].collect do |size|
  ["uint#{size}_t", "int#{size}_t"]
end.flatten + ['bool', 'float', 'char', 'double']

File.open(ARGV[0], 'w') do |output|
  output.puts <<END
// This file is generated by #{File.expand_path(__FILE__)}.
// DO NOT EDIT BY HAND!

#include <sys/types.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdio.h>

#include "aos/common/byteorder.h"

namespace aos {

bool PrintField(char *output, size_t *output_bytes, const void *input,
                size_t *input_bytes, uint32_t type) {
  switch (type) {
#{TypeNames.collect do |name|
  message_element = Target::MessageElement.new(name, 'value')
  statement = MessageElementStmt.new(name, 'value')
  message_element.size = statement.size
  print_args = []
  message_element.fetchPrintArgs(print_args)
  next <<END2
    case #{message_element.getTypeID()}:
      {
        if (*input_bytes < #{statement.size}) return false;
        *input_bytes -= #{statement.size};
        #{name} value;
        to_host(static_cast<const char *>(input), &value);
        int ret = snprintf(output, *output_bytes,
                           "#{statement.toPrintFormat()}",
                           #{print_args[0]});
        if (ret < 0) return false;
        if (static_cast<unsigned int>(ret) >= *output_bytes) return false;
        *output_bytes -= ret + 1;
        return true;
      }
END2
end.join('')}
    default:
      return false;
  }
}

}  // namespace aos
END
end

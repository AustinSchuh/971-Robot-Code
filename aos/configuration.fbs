include "reflection/reflection.fbs";

namespace aos;

// Table representing a channel.  Channels are where data is published and
// subscribed from.  The tuple of name, type is the identifying information.
table Channel {
  // Name of the channel.
  name:string;
  // Type name of the flatbuffer.
  type:string;
  // Max frequency in messages/sec of the data published on this channel.
  frequency:int = 100;
  // Max size of the data being published.  (This will be automatically
  // computed in the future.)
  max_size:int = 1000;

  // Sets the maximum number of senders on a channel.
  num_senders:int = 10;
  // Sets the maximum number of watchers on a channel.
  num_watchers:int = 10;

  // The schema for the data sent on this channel.
  schema:reflection.Schema;

  // The source node name for the data sent on this channel.
  // If nodes is populated below, this needs to also be populated.
  source_node:string;

  // The destination node names for data sent on this channel.
  // This only needs to be populated if this message is getting forwarded.
  destination_nodes:[string];
}

// Table to support renaming channel names.
table Map {
  // Channel to match with.  If the name in here matches, the name is replaced
  // with the name in rename.
  // Node specific matches are also supported.
  match:Channel;
  // The channel to merge in.
  rename:Channel;
}

// Application specific information.
table Application {
  // Name of the application.
  name:string;
  // List of maps to apply for this specific application.  Application specific
  // maps are applied in reverse order, and before the global maps.
  // For example
  //   "maps": [ { "match": { "name": "/foo" }, "rename": { "name": "/bar" } } ]
  // will make it so any channels named "/foo" actually go to "/bar" for just
  // this application.  This is super handy for running an application twice
  // publishing to different channels, or for injecting a little application
  // to modify messages live for testing.
  //
  //   "maps": [
  //     { "match": { "name": "/foo" }, "rename": { "name": "/bar" } },
  //     { "match": { "name": "/foo" }, "rename": { "name": "/baz" } }
  //   ]
  //
  // will map "/foo" to "/baz", even if there is a global list of maps.
  maps:[Map];

  // The node that this application will be started on.
  // TODO(austin): Teach starter how to use this for starting applications.
  node:string;
}

// Per node data and connection information.
table Node {
  // Short name for the node.  This provides a short hand to make it easy to
  // setup forwarding rules as part of the channel setup.
  name:string;

  // Hostname used to identify and connect to the node.
  hostname:string;
  // Port to serve forwarded data from.
  port:ushort = 9971;
}

// Overall configuration datastructure for the pubsub.
table Configuration {
  // List of channels.
  channels:[Channel] (id: 0);
  // List of global maps.  These are applied in reverse order.
  maps:[Map] (id: 1);

  // If present, this is the list of nodes in the system.  If this is not
  // present, AOS will be running in a single node configuration.
  nodes:[Node] (id: 4);

  // List of applications.
  applications:[Application] (id: 2);
  // List of imports.  Imports are loaded first, and then this configuration
  // is merged into them.
  imports:[string] (id: 3);
}

root_type Configuration;

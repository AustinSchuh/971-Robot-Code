#ifndef AOS_COMMON_QUEUE_TYPES_H_
#define AOS_COMMON_QUEUE_TYPES_H_

#include <sys/types.h>
#include <stdint.h>
#include <string.h>

#include <initializer_list>

#include "aos/common/macros.h"

namespace aos {

// Prints the value from 1 message field into output.
// output is where to write the text representation.
// output_bytes should point to the number of bytes available to write in
// output. It will be reduced by the number of bytes that were actually written.
// input is where to read the data in from (in network byte order, aka from
// Serialize).
// input_bytes should point to the number of bytes available to read from input.
// It will be reduced by the number of bytes that were actually read.
// type is the ID of a type to print. It must be a primitive type.
//
// Returns true for success and false for not.
//
// The implementation of this is generated by the ruby code.
bool PrintField(char *output, size_t *output_bytes, void *input,
                size_t *input_bytes, uint32_t type)
    __attribute__((warn_unused_result));

// The type IDs this uses are 2 parts: a 16 bit size and a 16 bit hash. Sizes
// for primitive types are stored with 8192 (0x2000) added.
//
// Serializing/deserializing includes all of the fields too.
struct MessageType {
  struct Field {
    // The type ID for the type of this field.
    uint32_t type;
    const char *name;
  };

  // Constructs a MessageType that doesn't own the storage for any of its
  // names.
  MessageType(uint32_t id, const char *name,
              ::std::initializer_list<const Field *> fields_initializer)
      : id(id), name(name), owns_names(false) {
    number_fields = fields_initializer.size();
    fields = new const Field *[number_fields];
    int i = 0;
    for (const Field *c : fields_initializer) {
      fields[i++] = c;
    }
  }

  ~MessageType() {
    for (int i = 0; i < number_fields; ++i) {
      if (owns_names) {
        delete fields[i]->name;
      }
      delete fields[i];
    }
    if (owns_names) {
      delete name;
    }
  }

  // Returns -1 if max_bytes is too small.
  ssize_t Serialize(char *buffer, size_t max_bytes) const;
  // bytes should start out as the number of bytes available in buffer and gets
  // reduced by the number actually read before returning.
  // Returns a new instance allocated with new or nullptr for error.
  static MessageType *Deserialize(const char *buffer, size_t *bytes);

  static bool IsPrimitive(uint32_t type_id) {
    return (type_id & 0x2000) != 0;
  }

  // The type ID for this.
  uint32_t id;
  const char *name;

  int32_t number_fields;
  const Field **fields;

 private:
  MessageType(int32_t number_fields, Field **fields)
      : name(nullptr),
        number_fields(number_fields),
        fields(const_cast<const Field **>(fields)),
        owns_names(true) {
    for (int i = 0; i < number_fields; ++i) {
      fields[i] = new Field();
    }
  }

  const bool owns_names;

  DISALLOW_COPY_AND_ASSIGN(MessageType);
};

// Implements a cache of types which generally works per-process but can (when
// instructed) put a type in shared memory which other processes will
// automatically be able to retrieve.
// All of these functions are thread-safe.
namespace type_cache {

// Makes sure a type is in the type cache. This will store a reference to type.
// The types of any non-primitive fields of type must already be added.
void Add(const MessageType &type);
// Retrieves a type from the type cache or shm. LOG(FATAL)s if it can't find it.
const MessageType &Get(uint32_t type_id);
// Makes sure a type is in the list in shm. Add must have already been called
// for type.
// Also adds the types of any non-primitive fields of type.
void AddShm(uint32_t type_id);

}  // namespace type_cache
}  // namespace aos

#endif  // AOS_COMMON_QUEUE_TYPES_H_
